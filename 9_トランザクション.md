# この章で学ぶこと

トランザクションの基本概念(ACID特性)

MVCCによる一貫性読み取りの仕組み

4つの分離レベルとその違い

ReadViewとUNDOログの動作原理

FOR UPDATEとSELECTの挙動の違い

## トランザクションとはなにか
全部成功するか全部失敗するか制御するもの(All or Nothing)

途中で失敗したら成功後の処理をロールバックして元に戻す

### 例1
```sql
START TRANSACTION;
INSERT INTO 注文 (注文ID, ユーザーID) VALUES ('X', 'XXX');
INSERT INTO 明細 (明細ID, 注文ID, 商品ID) VALUES ('X1', 'X', 'AAA');
INSERT INTO 明細 (明細ID, 注文ID, 商品ID) VALUES ('X2', 'X', 'BBB');
COMMIT;
```
ECサイトで注文と明細は同時に生成されなければならない

### 例2
```sql
START TRANSACTION;
UPDATE 口座 SET 残高 = 残高 - 1000 WHERE 口座ID = 'XXX';
UPDATE 口座 SET 残高 = 残高 + 1000 WHERE 口座ID = 'YYY';
COMMIT;
```
口座振込は加算と減算が同時に行われなければならない

### トランザクション中に別のトランザクションからSELECTしたらどうなる？
```sql
START TRANSACTION; -- trx A
UPDATE 口座 SET 残高 = 残高 - 1000 WHERE 口座ID = 'XXX'; -- trx A
SELECT * FROM 口座 WHERE 口座ID = 'XXX'; -- trx B
UPDATE 口座 SET 残高 = 残高 + 1000 WHERE 口座ID = 'YYY'; -- trx A
COMMIT; -- trx A
```
--trx Bが読み取る残高は更新前の値?更新後の値?
- A: 分離レベルによるがデフォルト(REPEATABLE READ)では更新前の値

### MVCC(Multi version Concurrency Control)
一貫性のある読み取り操作を実現するための機能

未コミットや途中コミットは無視するのでSELECT結果に一貫性がある

テーブルのある時点でのスナップショットからSELECTしている(ように見える)

### MVCCの仕組み テーブル内部構造
全てのテーブルには以下のカラムが内部的に付与されている
```sql
CREATE TABLE 会員 (
    会員ID INT AUTO_INCREMENT PRIMARY KEY,
    氏名 VARCHAR(100) NOT NULL,
    -- 内部用カラム
    DB_TRX_ID BINARY(6) NOT NULL, -- レコードを挿入/更新した最後のトランザクションのID
    DB_ROW_ID BINARY(6) NOT NULL, -- PKがない場合に付与される連番(会員はPKがあるため付与されない)
    DB_ROLL_PTR BINARY(7) NOT NULL -- 前回のUPDATE前のレコードを復元するUNDOログへのポインタ
)
```

### ReadView
ReadView: トランザクション開始時のアクティブトランザクション情報を記録