インデックスの速さを体感しよう
```sql
SELECT COUNT(*) FROM 書誌 WHERE タイトル LIKE 'プログラミング%'
```
0.15sec

インデックスを貼ると？
```sql
SHOW INDEX FROM 書誌;
CREATE INDEX idx_書誌_タイトル ON 書誌 (タイトル);
DROP INDEX idx_書誌_タイトル ON 書誌;
SELECT COUNT(*) FROM 書誌 WHERE タイトル LIKE 'プログラミング%'
```
0.01sec

15倍早くなる

インデックスの速さを体感しよう　解説

インデックスが効くとクエリは速くなる

explainで実行計画を確認するとインデックスが効いているか分かる

explain analyzeで実際の処理のloopがわかる

## データベースが内部的に利用する記録媒体(以下の3つある)の違い
| 媒体名 | アクセス速度(相対比) | 価格(相対比) | 揮発性 |
| :--- | :--- | :--- | :--- |
| RAM(メモリ) | 1倍(最速) | 100倍 | 揮発性 |
| SSD | RAMに対して約100~1000倍遅い | 10倍 | 不揮発性 |
| HDD | SSDに対して約10,000~100,000倍遅い | 1倍 | 不揮発性 |
- 揮発性：電源を消すとデータがなくなる

メモリ上でデータを読み書きするのが最速

しかしサーバーの電源を落とすとデータは消失する

だからSSD, HDDすなわち物理的なファイルとしてデータを記録しなければならない

### HDD
Track, Sectorで位置を特定

アームを移動して書き込むので低速

### データベースが使う記録媒体
| 処理 | 記録媒体 |
| :--- | :--- |
| データ永続化(ファイル書き込み) | SSD > HDD |
| SQLの読み書き | RAM(メモリ) |

いかにメモリ上で完結させて、ファイル書き込みを減らせるかが勝負

とはいえファイル書き込みもしないと情報が失われてしまう

### テーブルの中身はどうやって保存されているか
テーブルごとにインデックスやレコードがibdファイルに記録される
- バイナリーデータで保存され、人間が読める構造ではない

16KBのページという単位で区切られている

```sh
docker ps
docker exec -it container_id bash
head /var/lib/mysql/library/xxx.ibd
```

### インデックスはどう保存されているか
| 種類 | 特徴 | レコード有無 |
| :--- | :--- | :--- |
| クラスタインデックス | PKのインデックス | 有 |
| セカンダリインデックス | PK以外の全てのインデックス | 無 |

#### クラスタインデックスの構造
ページ：16KB単位で複数のレコード or 下位ページの参照を記録

ルートページ：インデックスアクセスで最初にみるページ(枝ページも同様)

リーフページ:実際のレコードが入っているページ

#### クラスタインデックスの構造詳細
ルート(枝)ページは下位ページのアドレスと境界値のPKを持つ

リーフページは15KBに収まる範囲で複数レコードを持つ

ページサイズの半分(8KB)を越えるレコードは作れない(BLOB, TEXT除く)

#### セカンダリインデックスの構造詳細
ルートページはクラスタインデックスと同じ構造

リーフページはインデックスに紐づくPKのみが入っている

セカンダリインデックスの参照のみのアクセス=カバリングインデックス

## インデックスはなぜはやいのか
フルテーブルスキャンは全ページの読み取りが必要

インデックススキャンは数ページの読み取りで十分

## バッファプール
バッファプール(メモリ)にページをキャッシュすることでアクセスを高速化

メモリが不足すると古いページから順次削除(URLキャッシュと呼ぶ)

### 課題1
インデックスを多く貼るほどINSERT/UPDATEの時間が伸びるのはなぜ？
- インデックスの数だけセカンダリインデックスのページ更新が発生するから

### 課題2
INTとVARCHAR(36)のPKを比較した時にINSERT/UPDATEが遅いのはどっち？理由は？
- VARCHAR(36)
- PKが大きいということはインデックスの各ページに入るデータ量が減り、ページの書込み頻度、すなわち遅いディスク書込みが発生しやすいから。

### 課題3
1回目のSELECTより2回目以降のSELECTが速かった。考えられる理由は？
- BufferPoolに読み込まれていないページへのアクセスが発生したため、ディスクからのページ読み取りが発生したから。2回目以降はメモリ上でのページアクセスのみだったため速くなった。

#### インデックスまとめ
InnoDBはテーブルを1ページ単位で管理している

インデックスはページ読み取り回数を大幅に減らすから速い

バッファプール(メモリ)にページがキャッシュされるほど速い